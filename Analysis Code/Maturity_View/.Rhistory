twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
howmany <- 0
pairs <- data.frame()
if(all.equal(primes[2]-primes[1],2) == TRUE){
pairs[1,] <- c(primes[1],primes[2])
howmany ,- howmany + 1
}
for(i in 2:(length(primes)-1)){
if(all.equal(primes[i+1]-primes[i],2) == TRUE){
pairs[i,] <- c(primes[i],primes[i+1])
howmany <- howmany + 1
}
}
twinp <- matrix(data = pairs, nrow = howmany,ncol = 2)
}
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
howmany <- 0
pairs <- data.frame()
if(all.equal(primes[2]-primes[1],2) == TRUE){
pairs[1,] <- c(primes[1],primes[2])
howmany <- howmany + 1
}
for(i in 2:(length(primes)-1)){
if(all.equal(primes[i+1]-primes[i],2) == TRUE){
pairs[i,] <- c(primes[i],primes[i+1])
howmany <- howmany + 1
}
}
twinp <- matrix(data = pairs, nrow = howmany,ncol = 2)
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
howmany <- 0
pairs <- data.frame()
if(all.equal(primes[2]-primes[1],2) == TRUE){
pairs[1,] <- c(primes[1],primes[2])
howmany <- howmany + 1
}
for(i in 2:(length(primes)-1)){
if(all.equal(primes[i+1]-primes[i],2) == TRUE){
pairs[i,] <- c(primes[i],primes[i+1])
howmany <- howmany + 1
}
}
return(pairs)
}
twinprimes(13)
all.equal(primes[2]-primes[1],2)
primes
primes <- c(2,  3,  5,  7, 11, 13)
all.equal(primes[2]-primes[1],2)
primes[2]-primes[1]
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <- data.frame()
if(all.equal((primes[2] - primes[1]) == 2)){
pairs[1,] <- c(primes[1],primes[2])
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs[i,] <- c(primes[i],primes[i+1])
}
}
return(pairs)
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <- data.frame()
if((primes[2] - primes[1]) == 2){
pairs[1,] <- c(primes[1],primes[2])
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs[i,] <- c(primes[i],primes[i+1])
}
}
return(pairs)
}
twinprimes(13)
pep <- data.frame()
pep[2] <- 2
pep
pep <- data.frame(ncol = 2)
pep
?data.frame
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <- matrix(0,nrow = 10, ncol = 2)
if((primes[2] - primes[1]) == 2){
pairs[1,] <- c(primes[1],primes[2])
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs[i,] <- c(primes[i],primes[i+1])
}
}
pairs
}
twinprimes(13)
pep <- cbind(pep)
pep
pep <- data.frame()
pep <- cbind(primes)
pep
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs[1,] <- c(primes[1],primes[2])
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs[i,] <- cbind(c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs[1,] <- c(primes[1],primes[2])
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- cbind(c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- cbind(c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- cbind(c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- cbind(c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- pairs + cbind(c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- rbind(c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- rbind(c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
?rbind2
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- rbind2(c(primes[1],primes[2]),pairs)
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- rbind2(c(primes[i],primes[i+1]),pairs)
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- rbind2(pairs,c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- rbind2(pairs,c(primes[i],primes[i+1]))
}
}
pairs
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- rbind2(pairs,c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- rbind2(pairs,c(primes[i],primes[i+1]))
}
}
as.matrix(pairs)
}
twinprimes(13)
#Question 3
twinprimes <- function(n){
sieve <- seq(2, n)
primes <- c()
for (i in seq(2, n)) {
if (any(sieve == i)) {
primes <- c(primes, i)
sieve <- c(sieve[(sieve %% i) != 0], i)
}
}
pairs <-data.frame()
if((primes[2] - primes[1]) == 2){
pairs <- rbind2(pairs,c(primes[1],primes[2]))
}
for(i in 2:(length(primes)-1)){
if((primes[i+1] - primes[i]) == 2){
pairs <- rbind2(pairs,c(primes[i],primes[i+1]))
}
}
twinp <- matrix(data = pairs, ncol = 2)
}
twinprimes(13)
sample(1:2,10,)
sample(1:2,10)
barplot(1:10)
# Load necessary libraries
library(ggplot2)
library(igraph)
library(dplyr)
# Read the data
nodes <- read.csv("large_twitch_features.csv")
setwd("C:/Users/zeyad/Dropbox/My PC (LAPTOP-1BHP0S7R)/Desktop/UBC/Fourth Year/Winter Term 1/COSC 421/cosc421project/Analysis Code/Maturity_View")
library(igraph)
library(dplyr)
# Read the data
nodes <- read.csv("large_twitch_features.csv")
edges <- read.csv("large_twitch_edges.csv")
# Set seed for reproducibility
set.seed(1)
# Sample nodes and filter edges for the sampled nodes
sampled_nodes <- sample(nodes$numeric_id, 100000, replace = FALSE)
filtered_edges_df <- edges %>% filter(edges$numeric_id_1 %in% sampled_nodes & edges$numeric_id_2 %in% sampled_nodes)
# Create a graph from the filtered edges
g <- graph_from_data_frame(d = filtered_edges_df, vertices = sampled_nodes, directed = FALSE)
# Detect communities using Louvain algorithm
community <- cluster_louvain(g)
# Get the size of each community
community_sizes <- sizes(community)
# Get the largest community
largest_community_id <- which.max(community_sizes)
largest_community <- which(community$membership == largest_community_id)
# Subgraph of the largest community
g_largest_community <- induced_subgraph(g, largest_community)
# Visualize the largest community
plot(g_largest_community,
vertex.size = 5,
vertex.label = NA,
vertex.color = "skyblue",
edge.color = "gray",
main = "Largest Community in the Graph")
library(igraph)
library(dplyr)
library(ggplot2)
# Step 1: Add community and maturity rating information to nodes
nodes$community <- community$membership[match(nodes$numeric_id, V(g)$name)]
# If your 'nodes' data has a 'maturity_rating' column
# Step 2: Aggregate view counts by both community and maturity rating
community_maturity_view_count <- nodes %>%
group_by(community, maturity_rating) %>%
summarise(total_view_count = sum(view_count, na.rm = TRUE),
average_view_count = mean(view_count, na.rm = TRUE),
community_size = n())
nodes$community <- community$membership[match(nodes$numeric_id, V(g)$name)]
nodes$community <- community$membership[match(nodes$numeric_id, V(g)$name)]
# If your 'nodes' data has a 'maturity_rating' column
# Step 2: Aggregate view counts by both community and maturity rating
community_maturity_view_count <- nodes %>%
group_by(community, mature) %>%
summarise(total_view_count = sum(view_count, na.rm = TRUE),
average_view_count = mean(view_count, na.rm = TRUE),
community_size = n())
# Step 1: Add community and maturity rating information to nodes
nodes$community <- community$membership[match(nodes$numeric_id, V(g)$name)]
# If your 'nodes' data has a 'maturity_rating' column
# Step 2: Aggregate view counts by both community and maturity rating
community_maturity_view_count <- nodes %>%
group_by(community, mature) %>%
summarise(total_view_count = sum(views, na.rm = TRUE),
average_view_count = mean(views, na.rm = TRUE),
community_size = n())
# Step 3: Visualize the total view count by community and maturity rating
ggplot(community_maturity_view_count, aes(x = factor(community), y = total_view_count, fill = factor(mature))) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Total View Count by Community and Maturity Rating",
x = "Community",
y = "Total View Count",
fill = "Maturity Rating") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Optional: You could also examine the average view count by community and maturity rating
ggplot(community_maturity_view_count, aes(x = factor(community), y = average_view_count, fill = factor(mature))) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Average View Count by Community and Maturity Rating",
x = "Community",
y = "Average View Count",
fill = "Maturity Rating") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Step 4: Statistical analysis (e.g., t-test for each community's views based on maturity rating)
# You can test if the average views are significantly different between maturity ratings
# Here we run the t-test for each community
t_test_results <- community_maturity_view_count %>%
group_by(community) %>%
summarise(t_test = list(t.test(views ~ mature))) %>%
mutate(p_value = sapply(t_test, function(x) x$p.value))
# Install necessary packages
install.packages("igraph")
install.packages("igraph")
# Install necessary packages
install.packages("igraph")
install.packages("statnet")
install.packages("statnet")
library(statnet)
nodes <- read.csv("large_twitch_features.csv")
edges <- read.csv("large_twitch_edges.csv")
set.seed(1)
sampled_nodes <- sample(nodes$numeric_id, 100000, replace = FALSE)
filtered_edges_df <- edges %>% filter(edges$numeric_id_1 %in% sampled_nodes & edges$numeric_id_2 %in% sampled_nodes)
# Load the libraries
library(igraph)
library(dplyr)
library(ggplot2)
nodes <- read.csv("large_twitch_features.csv")
edges <- read.csv("large_twitch_edges.csv")
set.seed(1)
sampled_nodes <- sample(nodes$numeric_id, 100000, replace = FALSE)
filtered_edges_df <- edges %>% filter(edges$numeric_id_1 %in% sampled_nodes & edges$numeric_id_2 %in% sampled_nodes)
g <- graph_from_data_frame(d = filtered_edges_df, vertices = sampled_nodes, directed = FALSE)
# 3.3 Community Detection using Louvain Method
# Apply Louvain community detection algorithm
louvain_communities <- cluster_louvain(g)
# Modularity score to assess the quality of the community structure
modularity_score <- modularity(louvain_communities)
print(paste("Modularity Score:", modularity_score))
# Plot the communities
plot(louvain_communities, g, main = "Twitch Streamer Communities")
# Get the community membership for each node
community_membership <- membership(louvain_communities)
# Count the size of each community
community_sizes <- table(community_membership)
# Get the top 5 largest communities by size
top_5_communities <- names(sort(community_sizes, decreasing = TRUE))[1:5]
# Subset the nodes belonging to these top 5 communities
top_5_nodes <- which(community_membership %in% top_5_communities)
# Create a subgraph containing only the top 5 communities
subgraph <- induced_subgraph(g, top_5_nodes)
# Plot the subgraph with the top 5 communities
plot(subgraph, vertex.size = degree(subgraph), vertex.color = community_membership[top_5_nodes],
main = "Top 5 Communities", vertex.label = NA) # Optionally remove labels for clarity
# Load the necessary libraries
library(igraph)
# Get the community membership for each node
community_membership <- membership(louvain_communities)
# Count the size of each community
community_sizes <- table(community_membership)
# Get the top 5 largest communities by size
top_5_communities <- names(sort(community_sizes, decreasing = TRUE))[1:5]
# Subset the nodes belonging to these top 5 communities
top_5_nodes <- which(community_membership %in% top_5_communities)
# Create a subgraph containing only the top 5 communities
subgraph <- induced_subgraph(g, top_5_nodes)
# Remove self-loops if present (optional for clarity)
subgraph <- simplify(subgraph, remove.loops = TRUE)
# Plot the subgraph with the top 5 communities
plot(subgraph,
vertex.size = 5,             # Reduce the size of the vertices for better visualization
vertex.color = community_membership[top_5_nodes],  # Color by community
main = "Top 5 Communities",
vertex.label = NA,           # Remove vertex labels
edge.width = 0.5,            # Thinner edges
edge.color = "gray",         # Gray edges for clarity
layout = layout.fruchterman.reingold)  # Use a fast layout
